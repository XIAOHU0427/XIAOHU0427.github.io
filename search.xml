<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue2和vue3的区别</title>
      <link href="/2023/12/15/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/12/15/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>##1.生命周期的变化<br><img src="https://i.postimg.cc/SQDdc2Bf/vue2-vue3.png" alt="vue2和vue3的区别"></p><p>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method.<br>onBeforeMount() : 组件挂载到节点上之前执行的函数。<br>onMounted() : 组件挂载完成后执行的函数。<br>onBeforeUpdate(): 组件更新之前执行的函数。<br>onUpdated(): 组件更新完成之后执行的函数。<br>onBeforeUnmount(): 组件卸载之前执行的函数。<br>onUnmounted(): 组件卸载完成后执行的函数.<br>onActivated():被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行。<br>onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。<br>onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。<br>##2.响应式原理</p><p>Vue2 响应式原理基础是Object.defineProperty；Vue3 响应式原理基础是Proxy。</p><p>object.defineProperty，初始化的时候，会遍历data中的所有成员，使用defineProperty把对象的属性转换成get和set<br>那Vue3 为何会抛弃它呢？那肯定是有一些缺陷的。主要原因：无法监听对象或数组新增、删除的元素。</p><p>proxy的性能本身就比defineProperty要好， 另外，代理对象可以拦截属性的访问、赋值、删除等操作，不需要初始化时遍历所有的属性。  另外，如果有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。  使用proxy默认就可以监听到动态新增的属性，可以监听到删除的属性。可以监听数组的索引和length属性。<br>##3.多根节点</p><p>Vue3 支持了多根节点组件.<br>Vue2中，编写页面的时候，我们需要去将组件包裹在<code>&lt;div&gt;</code>中，否则报错警告。<br>Vue3，我们可以组件包含多个根节点，可以少写一层。  </p><p>在Vue2中，模板(template).标签必须有一个根元素，这是因为Vue2中的编译器(compiler)需要将模板编译成一个render函数，而一个函数只能有一个返回值。因此，Vue2需要一个根元素来包含所有的子节点，以便编译器能够将它们编译成一个返回值。</p><p>而在Vue3中，通过使用Fragment(片段)标签或者空标签，可以在template标签中包含多个根元素。这是因为Vue3中使用了新的编译器，它能够将多个根节点编译成一个返回值。这样可以让开发者更方便地组织模板结构，使代码更加简洁和易读。</p><p>使用Fragment标签可以让开发者在不增加实际DOM节点的情况下，包含多个根节点。而空标签则可以在模板中作为占位符使用，以便在编译时被忽略，从而不会影响渲染结果。<br>##4.模板指令</p><p>v-if 和 v-for 指令：在 Vue 2.0 中，v-if 和 v-for 指令不能同时使用，因为 v-for 比 v-if 先执行，导致渲染出不必要的组件。</p><p>在 Vue 3.0 中，v-if 和 v-for 可以同时使用，但是需要将 v-if 指令放在 v-for 指令的父元素上：<br>##5.diff 算法</p><p>在 Vue 2.0 中，diff 算法是通过比较新旧虚拟 DOM 树来确定必须更新的 DOM 元素的最小集合。这个过程涉及到 DOM 树的遍历和对比，非常消耗性能，尤其是在更新大量数据时，会带来性能瓶颈。</p><p>Vue 3.0 中的 diff 算法进行了改进和优化，采用了编译时优化的动态标记，并使用静态分析技术来确定哪些节点是静态的，哪些是动态的。这样，在进行 diff 比较时，只需要对动态节点进行比较，避免了对静态节点的不必要操作，从而提高了性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题之vue</title>
      <link href="/2023/11/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BVue/"/>
      <url>/2023/11/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BVue/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vue优点"><a href="#1-vue优点" class="headerlink" title="1.vue优点"></a>1.vue优点</h2><p>轻量级 速度快 简单易学 低耦合 可重用性 独立开发 文档齐全，且文档为中文文档 </p><h2 id="2-vue等单页面应用及其优缺点"><a href="#2-vue等单页面应用及其优缺点" class="headerlink" title="2.vue等单页面应用及其优缺点"></a>2.vue等单页面应用及其优缺点</h2><p>优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。<br>缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化；第一次加载首页耗时相对长一些；</p><h2 id="3-什么是MVVM模型？"><a href="#3-什么是MVVM模型？" class="headerlink" title="3.什么是MVVM模型？"></a>3.什么是MVVM模型？</h2><p>MVVM是Model-View-ViewModel的缩写。<br>Model 层代表数据模型层，可以在 Model中定义数据修改和操作的业务逻辑；<br>View 代表UI 组件，它负责将数据模型转化成UI 展现出来，<br>ViewModel 是一个同步View 和 Model的对象。</p><h2 id="4-mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#4-mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="4.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>4.mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h2><p>mvc和mvvm其实区别并不大。都是一种设计思想。<br>主要就是mvc中Controller演变成mvvm中的 viewModel。mvvm主要解决了mvc中大量的DOM  操作使页面渲染性能降低，加载速度变慢，影响用户 体验。<br> &nbsp;&nbsp;&nbsp;区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br> &nbsp;&nbsp;&nbsp;场景：数据操作比较多的场景，更加便捷</p><h2 id="5-vue生命周期的理解"><a href="#5-vue生命周期的理解" class="headerlink" title="5.vue生命周期的理解"></a>5.vue生命周期的理解</h2><p> Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p><p>beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</p><p>created（创建后） ：实例创建完成，实例上配置的 options 包括<br>data、computed、watch、methods 等都配置完成，初始化数据,异步请求也适宜在这里调用,未挂载DOM，若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中</p><p>beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</p><p>mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。可在mounted钩子函数中对挂载的DOM进行操作。可在这发起后端请求，拿回数据，配合路由钩子做一些事情。</p><p>beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</p><p>updated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p><p>beforeDestroy（销毁前）：实例仍然完全可用，this 仍能获取到实例。可以执行一些清理操作，比如取消事件监听器或者清除定时器：</p><p>destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</p><h2 id="6-父子组件的生命周期执行顺序"><a href="#6-父子组件的生命周期执行顺序" class="headerlink" title="6.父子组件的生命周期执行顺序"></a>6.父子组件的生命周期执行顺序</h2><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。<br>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。  </p><p> &nbsp;&nbsp;&nbsp;加载渲染过程<br> &nbsp;&nbsp;&nbsp;父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</p><p> &nbsp;&nbsp;&nbsp;子组件更新过程<br> &nbsp;&nbsp;&nbsp;父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p> &nbsp;&nbsp;&nbsp;父组件更新过程<br> &nbsp;&nbsp;&nbsp;父 beforeUpdate -&gt; 父 updated</p><p> &nbsp;&nbsp;&nbsp;销毁过程<br> &nbsp;&nbsp;&nbsp;父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h2 id="7-Vue-组件间通信有哪些方式"><a href="#7-Vue-组件间通信有哪些方式" class="headerlink" title="7.Vue 组件间通信有哪些方式?"></a>7.Vue 组件间通信有哪些方式?</h2><p> 父组件通过props向下传递数据给子组件<br>子组件通过 $emit()给父组件发送消息，父组件通过v-on绑定事件接收数据。<br>兄弟通信，跨级通信：Vuex与localStorage</p><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</p><p><img src="https://i.postimg.cc/tTfpbGdH/vuex.png" alt="vuex存储"></p><p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：</p><p><img src="https://i.postimg.cc/Dw9W0hyk/loaclstorage.png" alt="localstorage"></p><p>eventbus<br>任意组件都可以通过EventBus来触发和监听自定义事件，从而实现组件之间的通信。<br>EventBus的优点是使用起来比较简单，不需要建立 props 和 events 的关系，而且可以在任意两个组件之间进行通信。缺点是事件的命名和传递参数需要手动管理，不够直观和明确，同时也容易出现命名冲突的问题。</p><h2 id="8-Vue-组件的-data-为什么必须是函数"><a href="#8-Vue-组件的-data-为什么必须是函数" class="headerlink" title="8.Vue 组件的 data 为什么必须是函数"></a>8.Vue 组件的 data 为什么必须是函数</h2><p>组件中的 data写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。<br>而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。</p><h2 id="9-双向数据绑定的原理"><a href="#9-双向数据绑定的原理" class="headerlink" title="9.双向数据绑定的原理"></a>9.双向数据绑定的原理</h2><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><p>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化  </p><p>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h2 id="10-说一下在-Vue-中如何检测数组的变化？"><a href="#10-说一下在-Vue-中如何检测数组的变化？" class="headerlink" title="10.说一下在 Vue 中如何检测数组的变化？"></a>10.说一下在 Vue 中如何检测数组的变化？</h2><p>Vue 中实现检测数组变化的方法，是将数组的常用方法进行了重写。Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。<br>这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><h2 id="11-说一下v-model的原理"><a href="#11-说一下v-model的原理" class="headerlink" title="11.说一下v-model的原理"></a>11.说一下v-model的原理</h2><p>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题之js</title>
      <link href="/2023/11/29/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjs/"/>
      <url>/2023/11/29/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjs/</url>
      
        <content type="html"><![CDATA[<h2 id="1-js数据类型"><a href="#1-js数据类型" class="headerlink" title="1.js数据类型"></a>1.js数据类型</h2><p>基本数据类型<br>Number、String、Boolean、Null、Undefined、Symbol、bigInt<br>引用数据类型<br>object、Array、Date、Function、RegExp  </p><h2 id="2-判断数据类型的方式有哪些？"><a href="#2-判断数据类型的方式有哪些？" class="headerlink" title="2.判断数据类型的方式有哪些？"></a>2.判断数据类型的方式有哪些？</h2><h3 id="typeof-适合对基本类型的判断"><a href="#typeof-适合对基本类型的判断" class="headerlink" title="typeof  适合对基本类型的判断"></a>typeof  适合对基本类型的判断</h3><p>typeof 运算符用于检测一个值的数据类型，它返回一个字符串表示数据类型。 </p><p><img src="https://i.postimg.cc/7ZNFQ5PX/typeof.png" alt="typeof运算符"></p><h3 id="Object-prototype-toString-call-一般用于复杂数据类型的判断"><a href="#Object-prototype-toString-call-一般用于复杂数据类型的判断" class="headerlink" title="Object.prototype.toString.call()一般用于复杂数据类型的判断"></a>Object.prototype.toString.call()一般用于复杂数据类型的判断</h3><p>Object.prototype.toString可以返回当前调用者的对象类型，所以一般用于复杂数据类型的判断。</p><h3 id="instanceof-判断复杂数据类型"><a href="#instanceof-判断复杂数据类型" class="headerlink" title="instanceof 判断复杂数据类型"></a>instanceof 判断复杂数据类型</h3><p>instanceof 运算符用于检测一个对象是否属于某个类或构造函数的实例。它返回一个布尔值，如果对象是指定类或构造函数的实例，则返回 true，否则返回 false。<br>&nbsp;&nbsp;&nbsp;特殊的：Array instanceOf Array &#x3D; false<br>&nbsp;&nbsp;&nbsp;Object instanceOf Object &#x3D; true  </p><p><img src="https://i.postimg.cc/BbqDp7mm/instanceof.png" alt="instanceof运算符"></p><h2 id="3-typeof-intanceof判断数据类型原理"><a href="#3-typeof-intanceof判断数据类型原理" class="headerlink" title="3.typeof,intanceof判断数据类型原理"></a>3.typeof,intanceof判断数据类型原理</h2><p><strong>typeof操作符的原理</strong>是基于JavaScript中的类型转换机制。它会将值转换为其对应的基本数据类型，并返回一个字符串表示该类型</p><p><strong>instanceof实现原理</strong>是判断对象的原型链中是否存在构造函数的原型对象。具体来说，它会沿着对象的原型链向上查找，直到找到构造函数的原型对象或者到达原型链的顶端（即 Object.prototype），如果找到了构造函数的原型对象，则返回 true，否则返回 false。</p><p>以下是一个简单的 &#x3D;&#x3D;instanceof 实现：&#x3D;&#x3D;</p><p><img src="https://i.postimg.cc/vTfY1Grj/instance.png" alt="instanceof实现"></p><p>该实现接受两个参数，分别是待检查的对象和构造函数。它使用 Object.getPrototypeOf() 方法获取对象的原型对象，然后沿着原型链向上查找，直到找到构造函数的原型对象或者到达原型链的顶端。如果找到了构造函数的原型对象，则返回 true，否则返回 false。</p><h2 id="4-判断数组的方式有哪些"><a href="#4-判断数组的方式有哪些" class="headerlink" title="4.判断数组的方式有哪些"></a>4.判断数组的方式有哪些</h2><p>通过instanceof做判断<br>通过Object.prototype.toString.call()做判断<br>通过原型链做判断</p><p><img src="https://i.postimg.cc/rs1TVQc2/image.png" alt="通过原型链判断"></p><h2 id="5-null和undefined区别"><a href="#5-null和undefined区别" class="headerlink" title="5.null和undefined区别"></a>5.null和undefined区别</h2><p>首先 Null 和 Undefined 都是基本数据类型，undefined 代表的含义是未定义，null 代表的含义是空对象。<br>一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化.</p><h2 id="6-闭包的理解"><a href="#6-闭包的理解" class="headerlink" title="6.闭包的理解"></a>6.闭包的理解</h2><p>闭包就是能够读取其他函数内部变量的函数。因为在JS中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “ 定义在一个函数内部的函数” 。&#x3D;&#x3D;只有当内部函数引用了外部函数的变量或参数时，才会形成闭包。&#x3D;&#x3D;</p><p>只有在函数内部定义的函数访问了外部函数的变量或参数，形成了引用关系，才会创建闭包。如果内部函数并没有引用任何外部的变量或参数，那么即使它在函数内部被定义和使用，也不会形成闭包。</p><p>好处：<br>&nbsp;&nbsp;&nbsp;可以读取函数内部的变量<br>&nbsp;&nbsp;&nbsp;将变量始终保持在内存中<br>&nbsp;&nbsp;&nbsp;可以封装对象的私有属性和私有方法<br>坏处<br>&nbsp;&nbsp;&nbsp;比较耗费内存、使用不当会造成内存溢出的问题<br>使用场景<br>&nbsp;&nbsp;&nbsp;模拟私有方法<br>&nbsp;&nbsp;&nbsp;setTimeout循环<br>&nbsp;&nbsp;&nbsp;匿名自执行函数<br>&nbsp;&nbsp;&nbsp;结果要缓存场景<br>&nbsp;&nbsp;&nbsp;实现类和继承  </p><h2 id="7-字符串的一些方法"><a href="#7-字符串的一些方法" class="headerlink" title="7.字符串的一些方法"></a>7.字符串的一些方法</h2><p>str.length：返回字符串的长度。  </p><p>str.toUpperCase()：将字符串中的所有字符转换为大写。  </p><p>str.toLowerCase()：将字符串中的所有字符转换为小写。  </p><p>str.charAt(index)：返回指定索引位置的字符。  </p><p>str.indexOf(searchValue [, fromIndex])：从指定位置开始搜索字符串中的指定值，并返回第一个匹配项的索引。  </p><p>str.lastIndexOf(searchValue [, fromIndex])：从指定位置开始反向搜索字符串中的指定值，并返回最后一个匹配项的索引。  </p><p>str.slice(startIndex [, endIndex])：提取字符串中指定索引范围内的字符并返回一个新字符串。</p><p>str.substring(startIndex [, endIndex])：与 slice() 方法类似，但不允许使用负数索引。  </p><p>str.substr(startIndex [, length])：从指定索引位置开始提取指定长度的字符并返回一个新字符串。  </p><p>str.replace(searchValue, replaceValue)：将字符串中的指定值替换为新的值并返回一个新字符串。  </p><p>str.trim()：去除字符串两端的空格并返回一个新字符串。  </p><p>str.split(separator [,limit])：将字符串按指定分隔符分割成一个数组并返回</p><h2 id="8-数组-array-方法"><a href="#8-数组-array-方法" class="headerlink" title="8.数组(array)方法"></a>8.数组(array)方法</h2><p>map : 遍历数组，返回回调返回值组成的新数组  </p><p>forEach : 无法 break ，可以用 try&#x2F;catch 中 throw new Error 来停止  </p><p>filter : 它可以用来筛选出数组中符合一定条件的元素，并返回这些元素组成的新数组。</p><p>some : 有一项返回 true ，则整体为 true</p><p>every : 有一项返回 false ，则整体为 false</p><p>join : 将数组中的所有元素转化为字符串，并使用指定的分隔符将它们连接起来，最终返回一个新字符串。</p><p>push &#x2F; pop : 末尾推入和弹出，改变原数组， 返回推入&#x2F;弹出项</p><p>unshift &#x2F; shift : 头部推入和弹出，改变原数组，返回操作项</p><p>sort(fn) &#x2F; reverse : 排序与反转，改变原数组</p><p>concat : 连接数组，不影响原数组， 浅拷贝</p><p>slice(start, end) : 返回截断后的新数组，不改变原数组</p><p>splice(start,number,value…): 返回删除元素组成的数组，value 为插入项，改变原数组start开始的起始位置，number是删除几个元素，value是添加的元素值</p><p>indexOf &#x2F; lastIndexOf(value, fromIndex) : 查找数组项，返回对应的下标</p><p>&#x3D;&#x3D;reduce&#x3D;&#x3D;<br>&nbsp;&nbsp;&nbsp;reduce方法会遍历数组中的每个元素，并将每个元素和累加器的值传递给回调函数进行操作。回调函数的返回值将成为下一次遍历时的累加器的值，最终返回的结果是最后一次回调函数的返回值。<br>&nbsp;&nbsp;&nbsp;accumulator表示累加器的初始值或者上一次回调函数的返回值，currentValue表示当前遍历到的元素，index表示当前元素的索引</p><p><img src="https://i.postimg.cc/Pf2Kc11C/reduce.png" alt="reduce实现"></p><h2 id="9-map与forEach的区别"><a href="#9-map与forEach的区别" class="headerlink" title="9.map与forEach的区别"></a>9.map与forEach的区别</h2><p>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</p><p>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</p><h2 id="10-数组去重"><a href="#10-数组去重" class="headerlink" title="10.数组去重"></a>10.数组去重</h2><p>Set 是 ES6 中新增的数据结构，它可以存储一组唯一的值。使用 Set 可以很方便地对数组进行去重。  </p><p><img src="https://i.postimg.cc/nVC3Q0sn/map.png" alt="set去重"></p><p>使用 filter 方法可以对数组进行过滤操作，返回一个新数组，新数组中只包含符合条件的元素。</p><p><img src="https://i.postimg.cc/hj9PC9vv/filter.png" alt="filter去重"></p><h2 id="11-数组扁平化"><a href="#11-数组扁平化" class="headerlink" title="11.数组扁平化"></a>11.数组扁平化</h2><p><img src="https://i.postimg.cc/hPxWVSJ4/image.png" alt="数组扁平化"></p><h2 id="12-for…in和for…of的区别"><a href="#12-for…in和for…of的区别" class="headerlink" title="12.for…in和for…of的区别"></a>12.for…in和for…of的区别</h2><p>for…in 获取的是对象的键名,  for…of 遍历获取的是对象的键值;</p><p>for… in 会遍历对象的整个原型链，而 for … of 只遍历当前对象不会遍历原型链；  </p><p>如果是对数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</p><h2 id="13-数组的遍历方法有哪些？"><a href="#13-数组的遍历方法有哪些？" class="headerlink" title="13.数组的遍历方法有哪些？"></a>13.数组的遍历方法有哪些？</h2><p><img src="https://i.postimg.cc/hPnM3gyt/image.png" alt="数组遍历"></p><h2 id="14-什么是原型、原型链？"><a href="#14-什么是原型、原型链？" class="headerlink" title="14.什么是原型、原型链？"></a>14.什么是原型、原型链？</h2><p>原型指的就是prototype，它是一个对象，我们在上面定义的属性和方法就是在原型上定义的。 </p><p>每一个对象都有一个隐式原型，指的就是__proto__，也就是通过它往上查找原型上的属性和方法，如果还没有那么会继续向上查找，直到找到最顶层的Object对象，它的__proto__是Null，这样一层一层通过__proto__向上查找的过程就是原型链  </p><p>在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个proto属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个proto指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。</p><h2 id="15-JS事件机制"><a href="#15-JS事件机制" class="headerlink" title="15.JS事件机制"></a>15.JS事件机制</h2><p>JS的事件机制有：事件冒泡(微软)、事件捕获(网景)。<br>捕获过程 -&gt; 目标阶段 -&gt; 冒泡阶段<br>addEventListenter 回调函数后一个参数：<br>true 事件捕获<br>false 事件冒泡 (默认)  </p><p>阻止事件冒泡<br>&nbsp;&nbsp;&nbsp;给子级加 event.stopPropagation()<br>&nbsp;&nbsp;&nbsp;在事件处理函数中返回 false<br>&nbsp;&nbsp;&nbsp;event.target&#x3D;&#x3D;event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；  </p><p>阻止默认事件<br>&nbsp;&nbsp;&nbsp;event.preventDefault()<br>&nbsp;&nbsp;&nbsp;return false</p><h2 id="16-call、apply、bind区别"><a href="#16-call、apply、bind区别" class="headerlink" title="16.call、apply、bind区别"></a>16.call、apply、bind区别</h2><p>call 和 apply 都是立即执行函数，bind 返回一个新函数。<br>call 和 apply 都可以传递参数，参数传递方式不同。call的参数是一个一个传递的，apply 的参数是一个数组。  <br>call 和 apply 改变函数的执行上下文后会立即执行该函数，而 bind 只是绑定了函数的执行上下文并返回一个新函数，需要手动调用该函数才能执行。</p><p>##17.深拷贝、浅拷贝的区别？如何实现深拷贝和浅拷贝？</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是指将一个对象的属性值复制到另一个对象，如果属性值是基本类型（Number、String、Boolean、undefined、null、Symbol、BigInt），则直接复制属性值，如果属性值是引用类型（Object、Array、Function），则复制的是引用，即两个对象会共享同一个引用类型的数据。<br><strong>浅拷贝的实现：</strong><br>可以通过 Object.assign()、展开运算符 …、Array.prototype.slice(), Array.prototype.concat()等方法手动实现浅拷贝。</p><p><img src="https://i.postimg.cc/tJ8bpJYw/image.png" alt="浅拷贝实现"></p><h3 id="深拷贝的实现有："><a href="#深拷贝的实现有：" class="headerlink" title="深拷贝的实现有："></a>深拷贝的实现有：</h3><p>JSON.parse 和 JSON.stringify<br>使用 JSON.parse() 和 JSON.stringify() 可以实现深拷贝，但是要求被拷贝的对象必须是 JSON 兼容的对象，不能包含函数、正则表达式等非 JSON 兼容的数据类型。</p><p><img src="https://i.postimg.cc/Qd8DD2tX/image.png" alt="浅拷贝实现"></p><p>JSON.parse(JSON.stringify)为什么可以实现深拷贝？<br>使用JSON.stringify将对象序列化，转成字符串后，存储在硬盘上，在通过JSON.parse()反序列化，将字符串转成对象  </p><p>通过JSON.stringify实现深拷贝有几点要注意<br>&nbsp;&nbsp;&nbsp;拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失<br>&nbsp;&nbsp;&nbsp;无法拷贝不可枚举的属性，无法拷贝对象的原型链<br>&nbsp;&nbsp;&nbsp;拷贝Date引用类型会变成字符串<br>&nbsp;&nbsp;&nbsp;拷贝RegExp引用类型会变成空对象<br>&nbsp;&nbsp;&nbsp;对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null<br>&nbsp;&nbsp;&nbsp;无法拷贝对象的循环应用(即obj[key] &#x3D; obj)  </p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题之CSS</title>
      <link href="/2023/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bcss/"/>
      <url>/2023/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bcss/</url>
      
        <content type="html"><![CDATA[<h2 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h2><p>标准盒模型和IE盒模型（怪异模型）。<br>它们的主要区别在于如何计算元素的宽度和高度。<br>在标准盒模型中，元素的宽度和高度只包括内容框的大小，不包括内边距、边框和外边距。<br>而在IE盒模型中，元素的宽度和高度包括内容框、内边距和边框的总和，即元素的实际宽度和高度等于内容框的宽度和高度加上内边距和边框的大小。<br><img src="https://i.postimg.cc/25s1GffF/box2.png" alt="标准盒模型"> </p><p><img src="https://i.postimg.cc/9fR2LRWs/d180f2c5-2894-4fe9-a42c-9d69c06eab12-17337976.png" alt="IE盒模型"></p><h2 id="2-水平垂直居中的实现"><a href="#2-水平垂直居中的实现" class="headerlink" title="2.水平垂直居中的实现"></a>2.水平垂直居中的实现</h2><p>1.使用 flex 布局：将父元素的 display 属性设置为 flex，并设置 align-items: center; justify-content: center; 即可实现水平垂直居中</p><p><img src="https://i.postimg.cc/85Tj9mjj/flex.png" alt="flex布局"></p><p>2.使用绝对定位和 margin：将子元素的 position 属性设置为 absolute，并设置 top: 50%; left: 50%; transform: translate(-50%, -50%); 即可实现水平垂直居中</p><p><img src="https://i.postimg.cc/dV4sDc1t/margin.png" alt="margin定位"></p><p>3.使用网格布局：将父元素的 display 属性设置为 grid，并设置 place-items: center; 即可实现水平垂直居中</p><p><img src="https://i.postimg.cc/cHfPgfmM/grid.png" alt="grid布局"></p><h2 id="3-flex-布局如何使用？"><a href="#3-flex-布局如何使用？" class="headerlink" title="3.flex 布局如何使用？"></a>3.flex 布局如何使用？</h2><h3 id="父级容器有以下属性："><a href="#父级容器有以下属性：" class="headerlink" title="父级容器有以下属性："></a>父级容器有以下属性：</h3><p>flex-direction，flex-wrap，flex-flow，justify-content，align-items，align-content。</p><p>flex-direction属性决定主轴的方向；</p><p><img src="https://i.postimg.cc/GhyJ0Yrd/flex-direaction.png" alt="flex-direaction"> </p><p>flex-wrap属性定义，如果一条轴线排不下，如何换行；<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap；<br>justify-content属性定义了项目在主轴上的对齐方式。<br>align-items属性定义项目在交叉轴上如何对齐。<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><h3 id="子级容器属性："><a href="#子级容器属性：" class="headerlink" title="子级容器属性："></a>子级容器属性：</h3><p>order属性，flex-grow属性，flex-shrink属性，flex-basis属性</p><p>order属性定义子元素或者子容器的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow属性定义子元素或者子容器的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-direction: 定义Flex容器中子元素的排列方向。<br>justify-content: 设置子元素在主轴上的对齐方式。<br>align-items:设置子元素在交叉轴上的对齐方式。<br>align-content: 设置多行子元素在交叉轴上的对齐方式。</p><h2 id="4-重绘和重排（回流）的区别？"><a href="#4-重绘和重排（回流）的区别？" class="headerlink" title="4.重绘和重排（回流）的区别？"></a>4.重绘和重排（回流）的区别？</h2><p>重绘：发生非几何信息的变化导致页面布局改变，比如改变某个元素的背景色、文字颜色、边框颜色等等</p><p>重排（回流）：发生几何信息变化导致页面布局的改变.</p><p>引发重排操作<br>&nbsp;&nbsp;&nbsp;添加、删除可见的dom<br>&nbsp;&nbsp;&nbsp;元素的位置改变<br>&nbsp;&nbsp;&nbsp;元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)<br>&nbsp;&nbsp;&nbsp;获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新。所以，在多次使用这些值时应进行缓存。</p><h2 id="5-说说-position的属性以及分别相对什么定位"><a href="#5-说说-position的属性以及分别相对什么定位" class="headerlink" title="5.说说 position的属性以及分别相对什么定位"></a>5.说说 position的属性以及分别相对什么定位</h2><p>relative（相对定位）：<br>元素的位置相对于其正常位置进行偏移，偏移的大小由top、right、bottom、left属性指定。相对定位的元素仍然占据文档流中的位置，不会对其他元素的布局产生影响。<br>fixed（固定定位）：<br>元素的位置相对于浏览器窗口进行偏移，不随滚动条的滚动而改变。固定定位的元素不再占据文档流中的位置，因此它不会对其他元素的布局产生影响。固定定位的元素可以使用z-index属性进行层叠控制。<br>absolute（绝对定位）：<br>元素的位置相对于最近的已定位祖先元素进行偏移，如果不存在已定位的祖先元素，则相对于body元素进行偏移。绝对定位的元素不再占据文档流中的位置，因此它不会对其他元素的布局产生影响。<br>static（静态定位）:<br>默认情况下是静态定位，静态定位的元素不受 top、bottom、left 和 right 属性的影响。position: static; 始终根据页面的正常流进行定位；</p><h2 id="6-清除浮动的方法"><a href="#6-清除浮动的方法" class="headerlink" title="6.清除浮动的方法"></a>6.清除浮动的方法</h2><p>&nbsp;&nbsp;&nbsp;1.给父元素设置height<br>&nbsp;&nbsp;&nbsp;2.给父元素设置float<br>&nbsp;&nbsp;&nbsp;3.给父元素设置after伪元素  </p><p>&nbsp;&nbsp;&nbsp;<img src="https://i.postimg.cc/sgjc5qYN/nihao.png" alt="伪元素"></p><p>&nbsp;&nbsp;&nbsp;4.给父元素设置overflow<br>&nbsp;&nbsp;&nbsp;overflow属性为元素对溢出内容的处理方式，可以将其值设置为hidden或者auto来包含子元素：</p><p>&nbsp;&nbsp;&nbsp;<img src="https://i.postimg.cc/vHHghsKf/overflow.png" alt="overflow"></p><p>&nbsp;&nbsp;&nbsp;5.可以添加一个不占用空间的after伪元素，将其clear属性设置为both：  </p><p>&nbsp;&nbsp;&nbsp;6.最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式，并给该元素写css样式： {clear:both;height:0;overflow:hidden;}</p><h2 id="7-浮动元素引起的问题？"><a href="#7-浮动元素引起的问题？" class="headerlink" title="7.浮动元素引起的问题？"></a>7.浮动元素引起的问题？</h2><p>父元素的高度无法被撑开，影响与父元素同级的元素<br>与浮动元素同级的非浮动元素会跟随其后<br>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</p><h2 id="8-选择器优先级"><a href="#8-选择器优先级" class="headerlink" title="8.选择器优先级"></a>8.选择器优先级</h2><p>! important&gt;行内样式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符&gt;继承</p><h2 id="9-display的属性值及其作用"><a href="#9-display的属性值及其作用" class="headerlink" title="9.display的属性值及其作用"></a>9.display的属性值及其作用</h2><p><img src="https://i.postimg.cc/SsM5H3tG/display.png" alt="display属性"></p><h2 id="10-visibility-hidden-与display-none的区别；"><a href="#10-visibility-hidden-与display-none的区别；" class="headerlink" title="10.visibility:hidden;与display:none的区别；"></a>10.visibility:hidden;与display:none的区别；</h2><p>visibility:hidden;和display:none; 他们的共同点是都可以隐藏元素  </p><p>visibility:hidden;会将元素隐藏，但仍然占据文档流中的位置，因此其他元素仍然会按照该元素原来的位置进行布局。元素的大小和位置等属性仍然存在，只是不可见了。  </p><p>相比之下，display:none;会将元素彻底从文档流中删除，其他元素将会顶替它的位置进行布局。元素的大小、位置等属性都不存在了。</p><h2 id="11-flex-1的使用场景？"><a href="#11-flex-1的使用场景？" class="headerlink" title="11.flex:1的使用场景？"></a>11.flex:1的使用场景？</h2><p>flex: 1 ，它可以使 flex 子元素在主轴方向上均匀地分配容器中的剩余空间。其中 “1” 是 flex-grow 属性的值，表示当有多余的空间时，这个元素可以增大，并按照比例分配剩余空间。  </p><p>1.创建等宽或等高的元素   一行之内左侧定宽右侧自适应<br>2.使一个元素占用剩余空间</p><h2 id="12-介绍下-BFC-及其应用"><a href="#12-介绍下-BFC-及其应用" class="headerlink" title="12.介绍下 BFC 及其应用"></a>12.介绍下 BFC 及其应用</h2><p>所谓 BFC，指的是一个独立的布局环境，BFC 内部的元素布局与外部互不影响。<br>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何变化，都不会影响到外部。</p><p>触发 BFC 的方式有很多，常见的有：<br>&nbsp;&nbsp;&nbsp;元素设置浮动：float 除 none 以外的值；<br>&nbsp;&nbsp;&nbsp;元素设置绝对定位：position (absolute、fixed)；<br>&nbsp;&nbsp;&nbsp;display 值为：inline-block、table-cell、table-caption、flex等；<br>&nbsp;&nbsp;&nbsp;overflow 值为：hidden、auto、scroll；  </p><p>常见的 BFC 应用场景有：<br>&nbsp;&nbsp;&nbsp;解决浮动元素令父元素高度坍塌的问题<br>&nbsp;&nbsp;&nbsp;解决非浮动元素被浮动元素覆盖问题<br>&nbsp;&nbsp;&nbsp;解决外边距垂直方向重合的问题  </p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题之html</title>
      <link href="/2023/11/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bhtml/"/>
      <url>/2023/11/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bhtml/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简述一下你对-HTML-语义化的理解？"><a href="#1-简述一下你对-HTML-语义化的理解？" class="headerlink" title="1.简述一下你对 HTML 语义化的理解？"></a>1.简述一下你对 HTML 语义化的理解？</h2><p> ①便于开发者容易理解。<br> ②机器容易理解结构(搜索、读屏软件)<br>&nbsp;&nbsp;&nbsp;<code>&lt;title&gt;</code>： 页面标题<br>&nbsp;&nbsp;&nbsp;<code>&lt;header&gt;</code>：页眉<br>&nbsp;&nbsp;&nbsp;<code>&lt;footer&gt;</code>:页脚<br>③搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，<span bgcolor=yellow>有利于SEO</span>;</p><h2 id="2-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#2-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><p>行内元素： <code>a</code>, <code>b</code>, <code>span</code>, <code>img</code>, <code>input</code>, <code>select</code>, <code>strong</code>;</p><p>块级元素： <code>div</code>, <code>ul</code>, <code>li</code>, <code>dl</code>, <code>dt</code>, <code>dd</code>, <code>h1-5</code>, <code>p</code>等；</p><p>空元素： <code>&lt;br&gt;</code>, <code>&lt;hr&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>;</p><h2 id="3-cookie-localStorage-sessionStorage区别"><a href="#3-cookie-localStorage-sessionStorage区别" class="headerlink" title="3.cookie, localStorage sessionStorage区别"></a>3.cookie, localStorage sessionStorage区别</h2><p>存储大小不同：cookie 的大小限制为 4KB 左右，localStorage 和 sessionStorage 的大小限制为 5MB 左右。</p><p>生命周期不同：cookie 可以设置过期时间，存储的数据在过期时间之前一直有效，而 localStorage ，除非被清理，否则一直存在；浏览器关闭还会保存在本地，但是不支持跨浏览器， sessionStorage 的存储数据仅在当前会话（session）中有效，会话结束后数据会被清空。</p><p>作用域不同：cookie 的作用域为整个域名下的所有页面，localStorage 和 sessionStorage 的作用域为当前页面及其打开的子页面。<br>与服务器的交互方式不同：cookie 会随着 HTTP 请求一起发送到服务器端，而 localStorage 和 sessionStorage 不会。</p><p>安全性不同：cookie 的存储数据可以被篡改，而 localStorage 和 sessionStorage 的存储数据不易被篡改。<br>一般来说，如果需要跨域名或跨浏览器的存储，可以选择使用 cookie；如果需要在本地长期存储数据，可以选择使用 localStorage；如果需要在当前会话中保存数据，可以选择使用 sessionStorage。<br>字符串键值对在本地存储数据</p><h2 id="4-从浏览器地址栏输入-url-到显示页面的步骤"><a href="#4-从浏览器地址栏输入-url-到显示页面的步骤" class="headerlink" title="4.从浏览器地址栏输入 url 到显示页面的步骤"></a>4.从浏览器地址栏输入 url 到显示页面的步骤</h2><p>&nbsp;&nbsp;&nbsp;1.浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求；</p><p>&nbsp;&nbsp;&nbsp;2.服务器交给后台处理完成后返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等）；</p><p>&nbsp;&nbsp;&nbsp;3.浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，建立相应的内部数据结构 （如 HTML 的 DOM）；</p><p>&nbsp;&nbsp;&nbsp;4.载⼊解析到的资源⽂件，渲染页面，完成。</p><p><a href="https://blog.csdn.net/Newbie___/article/details/107212575">更为详细版</a></p><h2 id="5-简述一下-src-与-href-的区别。"><a href="#5-简述一下-src-与-href-的区别。" class="headerlink" title="5.简述一下 src 与 href 的区别。"></a>5.简述一下 src 与 href 的区别。</h2><p>1、请求资源类型不同<br>（1） href标识超文本引用，href是引用和页面关联，是在当前元素和引用资源之间建立联系。常用的有：link、a。</p><p>（2）src是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，常用的有script，img 、iframe；</p><p>2、作用结果不同<br>（1）href 用于在当前文档和引用资源之间确立联系；</p><p>（2）src 用于替换当前内容；</p><h2 id="6-img-上-title-与-alt"><a href="#6-img-上-title-与-alt" class="headerlink" title="6.img 上 title 与 alt"></a>6.img 上 title 与 alt</h2><p>答案：title 指图片的信息、alt 指图片不显示时显示的文字</p><h2 id="7-Canvas-和-SVG-有什么区别？"><a href="#7-Canvas-和-SVG-有什么区别？" class="headerlink" title="7.Canvas 和 SVG 有什么区别？"></a>7.Canvas 和 SVG 有什么区别？</h2><h3 id="nbsp-nbsp-nbsp-Canvas"><a href="#nbsp-nbsp-nbsp-Canvas" class="headerlink" title="&nbsp;&nbsp;&nbsp;Canvas"></a>&nbsp;&nbsp;&nbsp;Canvas</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>通过 Javascript 来绘制 2D 图形。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>是逐像素进行渲染的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>其位置发生改变，会重新进行绘制。</p><h3 id="nbsp-nbsp-nbsp-SVG"><a href="#nbsp-nbsp-nbsp-SVG" class="headerlink" title="&nbsp;&nbsp;&nbsp;SVG"></a>&nbsp;&nbsp;&nbsp;SVG</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>一种使用 XML 描述的 2D 图形的语言<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加&nbsp;Javascript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SVG对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>&nbsp;&nbsp;&nbsp;1.svg 是一种矢量图，而 canvas 依赖于分辨率。所以 svg 放大不会失真，但是 canvas 绘制的图形会失真。<br>&nbsp;&nbsp;&nbsp;2.svg 支持事件处理器，而 canvas 不支持事件处理器。<br>&nbsp;&nbsp;&nbsp;3.svg 中的文字独立于图像，文字可保留，可编辑和可搜索，canvas 的文本渲染能力弱。<br>&nbsp;&nbsp;&nbsp;4.canvas 适合图像密集型的游戏，频繁地重绘图像，svg 绘制的复杂度高时减慢渲染的速度。<br>&nbsp;&nbsp;&nbsp;5.canvas 绘制的图形可以多种格式 (jpg、png) 保存图片，但是 svg 绘制的只能以 .svg 格式保存，使用时可以引入 html 文件。<br>&nbsp;&nbsp;&nbsp;6.canvas 适合开发游戏，svg 不适合游戏应用。</p><h2 id="8-如何进行SEO优化？"><a href="#8-如何进行SEO优化？" class="headerlink" title="8.如何进行SEO优化？"></a>8.如何进行SEO优化？</h2><p>SEO，即Search&nbsp;Engine&nbsp;Optimization，搜索引擎优化，是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。 </p><p>搜索引擎采用易于被搜索引用的手段，对网站进行有针对性的优化，提高网站在搜索引擎中的自然排名，吸引更多的用户访问网站，提高网站的销售能力和宣传能力，从而提升网站的品牌效应。  </p><p>合理的title(标题)、description（内容摘要）、keywords（关键词） </p><p>搜索对着三项的权重逐个减小，title值强调终点即可；description把页面内容高度概括，不可过分堆砌关键字；keywords例举出重要关键字。</p><h2 id="9-如何优化页面性能以提高用户体验？"><a href="#9-如何优化页面性能以提高用户体验？" class="headerlink" title="9.如何优化页面性能以提高用户体验？"></a>9.如何优化页面性能以提高用户体验？</h2><p>&nbsp;&nbsp;&nbsp;1.减少 HTTP 请求<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过合并 CSS 和 JavaScript 文件、使用 CSS Sprites 等技术来减少 HTTP 请求。  </p><p>&nbsp;&nbsp;&nbsp;2.压缩文件大小<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;压缩文件大小可以减少文件下载时间，从而提高页面加载速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用压缩工具对 CSS 和 JavaScript 文件进行压缩，从而缩小文件大小。</p><p>&nbsp;&nbsp;&nbsp;3.使用浏览器缓存<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器缓存可以大幅减少页面加载时间，减少服务器的负载。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过设置响应头中的缓存控制参数来控制缓存的时间和更新策略。</p><p>&nbsp;&nbsp;&nbsp;4.延迟加载资源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将一些不必要的资源进行延迟加载，例如图片懒加载、延迟加载 JavaScript 等技术可以减少页面的加载时间。</p><p>&nbsp;&nbsp;&nbsp;5.使用 CDN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 CDN 可以加速静态资源的加载速度，从而提高页面的性能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDN 可以将静态资源缓存在全球各地的服务器上，从而加速资源的加载速度。</p><p>&nbsp;&nbsp;&nbsp;6.优化图片<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图片是页面加载时间的主要因素之一，因此优化图片可以大幅提高页面的性能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过压缩图片、使用 WebP 格式、使用 CSS Sprites 等技术来优化图片。</p><p>&nbsp;&nbsp;&nbsp;7.避免使用过多的第三方库<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过多的第三方库会增加页面的加载时间，因此需要谨慎选择和使用第三方库。可以使用一些轻量级的替代方案，或者自己编写代码实现所需功能。<br>&nbsp;&nbsp;&nbsp;8.优化代码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优化代码可以减少页面的加载时间和渲染时间。可以通过减少 DOM 操作、尽量使用 CSS3 动画、避免使用同步请求等技术来优化代码。</p><h2 id="10-px、em、rem的区别及使用场景"><a href="#10-px、em、rem的区别及使用场景" class="headerlink" title="10.px、em、rem的区别及使用场景"></a>10.px、em、rem的区别及使用场景</h2><p>三者的区别：  </p><p>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。<br>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。<br>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。  </p><p>使用场景：  </p><p>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。<br>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git教程</title>
      <link href="/2023/11/15/git%E6%95%99%E7%A8%8B%EF%BC%88%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE%EF%BC%89/"/>
      <url>/2023/11/15/git%E6%95%99%E7%A8%8B%EF%BC%88%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>#1.安装<br>首先是下载，可以在官网下对应的。</p><p>但是官网很慢，所以我们可以靠tb镜像：</p><p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/%22tb%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BDgit%22">tb镜像下载git</a></p><p>下最新版，根据自己电脑的情况，比如我是64位我就下64的。</p><p>下载完毕后直接一路默认。选编译器那块，可以选自己用的，如vim、vscode。</p><p>下载完后打开终端输入git -v可以看到：  </p><p>mac:</p><p><img src="https://i.postimg.cc/85BMnGqt/mac.png" alt="mac"></p><p>window:   桌面单击右键可以看到：</p><p><img src="https://i.postimg.cc/MGTJRMsh/window.png" alt="window"></p><p>有以上两个其实就是安装成功了。</p><p>其中，GUI是图形界面，不适合初学者；一般我们都用的是上面的Bash，点击后会进入命令行输入框。</p><p>#配置</p><p>打开Git Bush</p><p>可以查看git中的所有配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -l</span><br></pre></td></tr></table></figure><p>配置用户名和密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名称&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>查看当前用户配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><blockquote><p>git工作的流程：<br>在工作目录中添加、修改文件-&gt;<br>将需要进行版本管理的文件放入暂存区域-&gt;git add .<br>查看状态： git status<br>将暂存区域的文件提交到git仓库-&gt;git commit<br>推送到远程仓库。 git pull</p></blockquote><p>git status用法</p><p>通过git init 初始化一个git仓库，通过git status命令发现有两个未被git追踪 的文件，</p><p>使用git add命令将这两个文件添加到暂存区之后，</p><p>再次使用git status命令，发现有两个文件可以被commit,就是我们刚刚添加的两个文件，<br>git 提示我们可以使用<code>git rm --cached &lt;file&gt;...</code>来删除暂存区内不想要的文件，接下来通过git commit进行第一次commit，再次使用git status命令查看显示工作目录和暂存区的状态。</p><p><img src="https://i.postimg.cc/nrKPNpR4/git.png" alt="git"></p><p>重点：</p><p>git status命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用git log.</p><p>#项目创建及克隆</p><p>如果我们要创建本地仓库有两种方式：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>##创建全新仓库</p><p>需要用到git管理的项目的根目录执行。</p><p>我设置了一个空的文件夹：</p><p>接着，右键选择Git Bash，进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>初始化后会出现一个.git文件，但是这个文件是默认隐藏的，需要设置取消隐藏才能看到：</p><p><img src="https://i.postimg.cc/nrKPNpR4/git.png" alt="git初始化文件"></p><p>##克隆远程仓库</p><p>如果在远程仓库上有项目，可以使用进行克隆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone url</span><br></pre></td></tr></table></figure><p>#遇到的问题</p><p>##1.提交代码，忘记从远程仓库拉取最新代码，导致本地最新修改的代码无法提交上去</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config pull.rebase false</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/25ZR2RDw/status.png" alt="无法提交代码"></p><p>##2. 删除本地分支（分支名写错了，或不是从目标分支拉取的代码，想删掉重新拉分支）</p><p>如果你还在一个分支上，那么 Git 是不允许你删除这个分支的。所以，请记得退出分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>通过 <code>git branch -d &lt;branch&gt;</code>删除一个分支，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d fix/authentication</span><br></pre></td></tr></table></figure><p>##3.远程删除分支</p><p>使用这个命令可以远程删除分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --delete &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>比如： <code>git push origin --delete fix/authentication</code>，这个分支就被远程删除了。</p><p>你也可以使用这行简短的命令来远程删除分支：<code>git push &lt;remote&gt; :&lt;branch&gt;</code> 比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :fix/authentication</span><br></pre></td></tr></table></figure><p>如果你得到以下错误消息，可能是因为其他人已经删除了这个分支。</p><blockquote><p>error: unable to push to unqualified destination: remoteBranchName The destination refspec neither matches an existing ref on the remote nor begins with refs&#x2F;, and we are unable to guess a prefix based on the source ref. error: failed to push some refs to ‘git@repository_name’</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
